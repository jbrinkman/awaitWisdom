#n Wyam.Modules.Yaml -p
#n Wyam.Modules.Markdown -p
#n Wyam.Modules.Razor -p
#n Wyam.Modules.Less -p
#n Wyam.Modules.Html -p

#an "System.ServiceModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
#an "System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"

public static class Utilities 
{
    public static string GetTagLink(string tag)
	{
		if(tag.StartsWith("."))
		{
		    tag = tag.Substring(1);
		}
        
		return @"Tags/" + tag.ToLowerInvariant().Replace(' ', '-');
	}
}

-----------------------------------------------------------------------
FileSystem.InputPaths.Clear();
FileSystem.InputPaths.Add( DirectoryPath.FromString("Input"));
FileSystem.OutputPath = "Output";


Pipelines.Add("Posts",
	ReadFiles(@"Posts\*.md"),  // Read all markdown files in the "posts" directory
	FrontMatter(Yaml()),  // Load any frontmatter and parse it as YAML markup
	Markdown().EscapeAt(true),  // Render the markdown content
	Concat(
		ReadFiles(@"Posts\*.cshtml")
            .Where(x => Path.GetFileName(x.Path.ToString())[0] != '_' && Path.GetFileName(x.Path.ToString()) != "Index.cshtml"),
		FrontMatter(Yaml())
	),
	Razor(),  // Compile and render the page template
	Excerpt(),
	WriteFiles(@".html"),  // Write the post file
    Branch(
        OrderBy((d,c)  => d.Get<DateTimeOffset>("Published")).Descending(true),
        Rss(    siteUri: "https://blog.awaitWisdom.com",
                rssPath: "feed.rss",
                feedTitle: "await Wisdom()",
                feedDescription: "Just a blog"
            )
            .WithLanguage("en-us")
            .WithPublicationDateMetaKey("Published")
            .WithTitleMetaKey("Title")
            .WithDescriptionMetaKey("Description")
            .WithLinkCustomizer((link) => 
                {
                    var ls = link.ToString();
                    return ls.EndsWith("/index.html") 
                            ? FilePath.FromString(ls.Substring(0, ls.IndexOf("/index.html"))) 
                            : link;
                }),
        WriteFiles()
    ),
    Branch(
        Where((d,c) => d.Get<string[]>("Tags", new string[0]).Any() && d.Get<string[]>("Tags").Contains("Tech")),
        OrderBy((d,c)  => d.Get<DateTimeOffset>("Published")).Descending(true),
        Rss(    siteUri: "https://blog.awaitWisdom.com",
                rssPath: "techfeed.rss",
                feedTitle: "await Wisdom()",
                feedDescription: "Just a blog"
            )
            .WithLanguage("en-us")
            .WithPublicationDateMetaKey("Published")
            .WithTitleMetaKey("Title")
            .WithDescriptionMetaKey("Description")
            .WithLinkCustomizer((link) => 
                {
                    var ls = link.ToString();
                    return ls.EndsWith("/index.html") 
                            ? FilePath.FromString(ls.Substring(0, ls.IndexOf("/index.html"))) 
                            : link;
                }),
        WriteFiles()
    )
);

Pipelines.Add("SitePages",
    ReadFiles(@"**.md")
        .Where(x => !Path.GetDirectoryName(x.Path.ToString()).EndsWith(@"Posts")),
	FrontMatter(Yaml()),
	Markdown().EscapeAt(true),
    Concat(
        ReadFiles(@"*.cshtml")
            .Where(x => Path.GetFileName(x.Path.ToString())[0] != '_' && !Path.GetDirectoryName(x.Path.ToString()).EndsWith("Posts")),
		FrontMatter(Yaml())
	),
	Razor(),
	WriteFiles(@".html")
);

Pipelines.Add("Tags",
	ReadFiles(@"Tags\index.cshtml"),
	FrontMatter(),
    Razor(),
    WriteFiles(@".html"),
	Execute(@ctx.Documents
		.Where(x => x.ContainsKey("Published") && x.ContainsKey("Tags"))
    	.SelectMany(x => x.Get<string[]>("Tags"))
		.Distinct()
		.Select(x => @ctx.GetDocument(@doc, new Dictionary<string, object>()
		{
		    { "Title", x },
			{ "Tag", x }
		}))),
	Razor(),
	WriteFiles( Utilities.GetTagLink(@doc.String("Tag")) + ".html")
);

Pipelines.Add("Less",
    ReadFiles(@"**.less"),
    Less(),
    WriteFiles(@".css")
);

var disallowedExt = new []{".cshtml", ".md", ".less"};
Pipelines.Add("Resources",
	CopyFiles("**").Where(f => !disallowedExt.Contains(f.Path.Extension))
);